\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

The aim of this tutorial is to teach people somewhat familiar with the
Soar cognitive architecture how to write a Soar agent to control a Cozmo
robot. It assumes that Soar is already installed on your computer and
that you have the Soar-Cozmo Interface code ready to be run. Files
associated with each part of the tutorial are included in this
directory, and should be able to be sourced presently. When reading a
lesson, I strongly suggest opening the associated \texttt{.soar} file or
tutorial folder and keeping it handy so that you can reference it while
reading the tutorial. Ideally, by the end of the tutorial, you should
understand what the inputs made available to Soar by Cozmo are and what
they do, as well aome of the commands Soar can output to Cozmo and what
these do. Although the tutorial will not cover every available Cozmo
action currently supported, I hope it will cover enough to give you the
context and background needed to understand the rest through inspection
of the documentation and the interface code. Before getting into
examples, we will first go over the higher-level mechanics of how the
interface works.

\hypertarget{how-it-works}{%
\section{How It Works}\label{how-it-works}}

First, it is important to note that the interface code is purely
\emph{reactive} to the Soar kernel, which is considered primary. That
means the Soar kernel and its cycle is what drives the interface, rather
than any internal loop in the interface itself. All of the functionality
of the interface is within various \emph{callback} functions, which are
triggered by the Soar kernel, execute their code, and then return
control to the kernel. Two callback functions in particular are used to
provide the two primary functions of the interface: providing
information about the Cozmo and its perceptions on the input link and
watching the output link for actions the agent wants Cozmo to perform.

\hypertarget{input}{%
\subsection{Input}\label{input}}

The input is achieved by a callback triggered when the Soar cycle is
about to enter the input phase. When the cycle reaches that point, the
interface polls the Cozmo robot for all the information which needs to
be presented to Soar such as its pose, the status of its lift, and any
objects or faces it can see. We will cover the details of how this
information is presented later. Once it has the appropriate information
from Cozmo, the interface updates the agent's working memory elements
through the Soar Markup Language, and passes control back to the kernel,
which proceeds into the input phase. By updating the working memory
elements before the input phase, we ensure that the agent has the latest
information available.

\hypertarget{output}{%
\subsection{Output}\label{output}}

Control of the Cozmo robot is achieved by a callback which listens for
changes to the output link, then scans it for new working memory
elements with names of actions Cozmo can take. For example, if the
output link is initially empty and Soar adds a new identifier
augmentation \texttt{\^{}move-lift\ M1} which has an float augmentation
\texttt{\^{}height\ 0.5}, the new output link would look like

\begin{verbatim}
(I3 ^move-lift M1)
  (M1 ^height 0.5)
\end{verbatim}

and the output callback would be triggered. It would be given the new
output link identifier augmentation \texttt{\^{}move-lift\ M1}, and then
see if the attribute name ``move-lift'' is an action it recognizes.
Since it is, it will look at the identifier \texttt{M1} and try and find
the \texttt{\^{}height} attribute. The value of the \texttt{\^{}height}
attribute is used in a function call to the Cozmo SDK which will move
the lift to the specified level, in this case 50\% of its maximum
height. Once the Cozmo finishes the action, a
\texttt{\^{}status\ complete} augmentation is added \texttt{M1}, so the
final output link looks like

\begin{verbatim}
(I3 ^move-lift M1)
  (M1 ^height 0.5 ^status complete)
\end{verbatim}

Control is then handed back to the Soar kernel, which continues to run
its cycle. If more than one new valid action is added to the output link
Cozmo will execute all of them before handing back control. The order of
execution should be treated as random.

\hypertarget{lessons}{%
\section{Lessons}\label{lessons}}

To ground that rather abstract description of the interface, and to
provide examples of the specific inputs and outputs the interface
provides and handles, we will go through a series of lessons which
incrementally build on each other, ultimately producing a Soar agent
which will look around its environment for light cubes and a face, and
then bring the ``most valuable'' light cube to the face.

\hypertarget{lesson-1-reset-cozmos-head-and-lift}{%
\subsection{Lesson 1: Reset Cozmo's Head and
Lift}\label{lesson-1-reset-cozmos-head-and-lift}}

First, we'll explore how to move Cozmo's head and lift to specific
positions using the \texttt{move-head} and \texttt{move-lift} commands.
The \texttt{move-head} action sets the angle on Cozmo's head relative to
a horizontal plane through its axis of rotation. Thus, if the angle
specified is -0.25, Cozmo's head will move so that it forms a -0.25
radian angle with the plane, which ends up having Cozmo look towards the
ground. An angle of 0.25 will similarly have Cozmo look upwards. The
\texttt{move-lift} action moves the lift to a position specified in the
command by a real number between 0 and 1. The number indicates the
percentage of the lifts maximum height it should move to, so a value of
0 is the lowest possible height for the lift, a value of 1 is the
highest, and 0.5 is the lift's midpoint.

We will be using the \texttt{move-head} and \texttt{move-lift} actions
to reset Cozmo's head and lift positions to default ones. Specifically,
we want Cozmo to move its head to be parallel with the ground and to
lower its lift as far as it can. Together, these actions will help Cozmo
see better, since Cozmo often starts with its tilted down, and the lift
can occasionally block Cozmo's camera. In order to make sure Cozmo
always resets when the Soar agent starts, we will make a slight addition
to the usual initialization production for a Soar agent. The
initialization proposal rule is a cookie-cutter proposal which just
proposes the \texttt{initialize-cozmo} operator. The application rule
checks for the presence of this operator, and then has two parts. The
first is fairly standard: it adds a \texttt{\^{}name} string
augmentation to the top state and sets its value to ``cozmo''. The
second is what resets the positions of Cozmo's lift and head:

\begin{verbatim}
(<out>  ^move-head.angle 0.0
        ^move-lift.height 0.0)
\end{verbatim}

This part of the right hand side (RHS) adds two working memory elements
to the output link, \texttt{\^{}move-head} and \texttt{move-lift}, and
gives them each an augmentation, \texttt{\^{}angle} for
\texttt{\^{}move-head} and \texttt{\^{}height} for \texttt{move-lift},
which are set to 0.0. Recall that the interface listens for new
additions to the output link. This means that when this rule fires, the
interface will pause the kernel to look for valid actions, which both
new WMEs are. The interface will be looking for an \texttt{\^{}angle}
attribute on the \texttt{\^{}move-head} identifier and a
\texttt{\^{}height} attribute on the \texttt{\^{}move-lift} identifier.
Since both are present and supply valid values, the interface will
execute the specified actions in the Cozmo robot.

\hypertarget{lesson-2-saving-the-origin-pose}{%
\subsection{Lesson 2: Saving the Origin
Pose}\label{lesson-2-saving-the-origin-pose}}

The first input we will be looking at will be Cozmo's pose information,
which is always placed by the interface on the agent's input link and
will look similar to:

\begin{verbatim}
(I2 ^pose P1)
    (P1 ^rot 2.733525 ^x 31.371500 ^y 1.045640 ^z 0.000000)
\end{verbatim}

The pose identifier will have four attributes with floating point
values, \texttt{\^{}rot}, \texttt{\^{}x}, \texttt{\^{}y}, and
\texttt{\^{}z}, indicating Cozmo's rotation on the z (vertical) axis in
radians and its position on the x-y plane from the origin in
millimeters. Although these values are just estimations based on Cozmo's
internal sensors, they are never-the-less useful in keeping track of
where Cozmo is. Right now, we are going to make sure that Cozmo also
keeps track of where it started by saving Cozmo's initial pose when it
starts up. This will involve modifying both the proposal and the
application rule we touched on in the last lesson.

First, we need to modify the proposal rule so that the
\texttt{initialize-cozmo} operator has the initial pose information. In
the left hand side (LHS), add a new condition
\texttt{\^{}io.input-link.pose\ \textless{}p\textgreater{}}, like so:

\begin{verbatim}
(state <s>  ^superstate nil
           -^name
            ^io.input-link.pose <p>)
\end{verbatim}

Then add a few more conditions based on augmentations of
\texttt{\textless{}p\textgreater{}} to get the actual values of the
pose:

\begin{verbatim}
(<p> ^rot <r-val>
     ^x <x-val>
     ^y <y-val>
     ^z <z-val>)
\end{verbatim}

This will look at the pose information on the agent's input link and
store the values in the variables
\texttt{\textless{}r-val\textgreater{}},
\texttt{\textless{}x-val\textgreater{}},
\texttt{\textless{}y-val\textgreater{}}, and
\texttt{\textless{}z-val\textgreater{}}, so that we can attach them to
the operator.

On the RHS, add a new attribute \texttt{\^{}origin} to the operator
\texttt{\textless{}op\textgreater{}} which has a new identifier as its
value, so it looks like:

\begin{verbatim}
(<op>   ^name initialize-cozmo
        ^origin <ogn>)
\end{verbatim}

and then expand \texttt{\textless{}ogn\textgreater{}}, adding
\texttt{\^{}rot}, \texttt{\^{}x}, \texttt{\^{}y}, and \texttt{\^{}z}
augmentations, giving each as their value the matching variable from the
LHS:

\begin{verbatim}
(<ogn>  ^rot <rot>
        ^x <x-val>
        ^y <y-val>
        ^z <z-val>)
\end{verbatim}

Now the operator has the pose information we want to store, which means
the application rule an pull directly from the operator. Now we need to
modify the application rule so that it actually stores the origin pose
on the top state. First, modify its LHS a bit by looking for an
\texttt{\^{}origin\ \textless{}ogn\textgreater{}} augmentation on the
operator and, like above, get the relevant augmentations from
\texttt{\textless{}ogn\textgreater{}} so that the agent stores the
rotation and location information in the variables
\texttt{\textless{}r-val\textgreater{}},
\texttt{\textless{}x-val\textgreater{}},
\texttt{\textless{}y-val\textgreater{}}, and
\texttt{\textless{}z-val\textgreater{}}. On the RHS, create an
\texttt{\^{}origin\ \textless{}origin\textgreater{}} augmentation on the
top state \texttt{\textless{}s\textgreater{}}, like so:

\begin{verbatim}
(<s>    ^name cozmo
        ^origin <origin>)
\end{verbatim}

Note that the name of the new identifier (i.e.,
\texttt{\textless{}origin\textgreater{}}) must be different than the
variable used to match the operator's augmentation (i.e.,
\texttt{\textless{}ogn\textgreater{}}). Then add the necessary
augmentations like before by adding a new effect:

\begin{verbatim}
(<origin>   ^rot <rot>
            ^x <x-val>
            ^y <y-val>
            ^z <z-val>)
\end{verbatim}

Note that \texttt{\textless{}origin\textgreater{}} is an augmentation to
the top state, rather than the input link, because it is not an input
but a memory. Additionally, because we check for an operator in the LHS,
the \texttt{\textless{}origin\textgreater{}} WME is \emph{o-supported},
meaning it will persist even after the rule which added it
(\texttt{apply*initialize-cozmo}) is retracted. Thus, we have a
permanent record of where Cozmo started.

\hypertarget{lesson-3-remembering-objects-and-faces}{%
\subsection{Lesson 3: Remembering Objects and
Faces}\label{lesson-3-remembering-objects-and-faces}}

Now that Cozmo moves its face and lift so that it can see, and remembers
where it started, we need to begin giving it some capabilities for
observing the world around it. In order to keep the tutorial files
small, from here on out we'll be working on a single Soar project,
contained in the \texttt{cozmo/} folder. If you want to work through the
this tutorial, I suggest similarly creating a folder to house multiple
soar files and to copy and paste the \texttt{elaborations/} sub-folder
and the \texttt{cozmo\_source.soar} file to it. These provide some basic
functionality like elaborating the top state and giving you a single
soar file to run. Specifically, you can run the tutorial agent by using
\texttt{cozmo\_source.soar} as your agent file. For this lesson, look at
the file \texttt{cozmo/remember.soar}.

Before Cozmo can bring you the most valuable light cube it sees, it must
not only find light cubes and your face but be able to remember where
those things are. First, we will be giving Cozmo the ability to remember
details like the location, name, and id of objects and faces it sees,
even after they leave its pereption. The core of this process is
watching for new objects or faces, copying the various augmentations
attached to these, and then storing them on the top state as o-supported
WMEs for later access. Additionally, we want Cozmo to be able to update
its old knowledge if anything about the object (e.g., it's locaton)
changes, so we need Cozmo to be comparing objects in its perception with
those it remembers and be able to update the information in its memory
if needed.

\hypertarget{remembering-new-cubes}{%
\subsubsection{Remembering New Cubes}\label{remembering-new-cubes}}

For this task, the only kinds of objects we need to remember are light
cubes, which is helpful because light cubes have some unique pieces of
information which we want to capture, and we can do so without needing
to separately check for plain objects. The first thing we need to do is
have the Soar agent propose an operator remembering a cube which it
hasn't seen before, and attach whatever information is pertinent to that
operator. We will call this rule
\texttt{cozmo*propose*remember-new-cube}, and it should look for an
\texttt{\^{}object\ \textless{}obj\textgreater{}} identifier
augmentation on the input-link with certain augmentations of its own,
and should also make sure that the object seen isn't one we already
remember. The entire LHS of the proposal should look like:

\begin{verbatim}
(state <s> ^name cozmo
           ^io.input-link.object <obj>)
   (<obj> ^type cube
          ^cube-id <cid>
          ^object-id <oid>
          ^pose <p>)
   (<p> ^rot <r-val>
        ^x <x-val>
        ^y <y-val>
        ^z <z-val>)
  -(<s> ^cube.cube-id <cid>)
\end{verbatim}

The \texttt{\^{}type\ cube} augmentation we look for on the
\texttt{\textless{}obj\textgreater{}} identifier ensures that the object
in question is indeed a light cube. This isn't strictly necessary, since
only light cubes are given a \texttt{\^{}cube-id} attribute, but I want
to introduce the presence of that augment as a simple test for cubeness.
The \texttt{\^{}cube-id\ \textless{}cid\textgreater{}} condition
captures the cube's id in the \texttt{\textless{}cid\textgreater{}}
variable; each light cube has a unique ID which is tied to the image on
the cube itself. This means that we are guaranteed that any object on
the input link with an augmentation matching
\texttt{\^{}cube-id\ \textless{}cid\textgreater{}} is guaranteed to be
this particular cube. \texttt{\textless{}oid\textgreater{}} stores the
cube's object id, which is a temporary internal id given to the object
by Cozmo. An object's object id will remain the same as long as Cozmo
senses the object, and no two objects will have the same object id
simultaneously. We need to keep track of the cube's object id because it
is needed for certain actions such as picking up the cube.

Finally, we have the pose data, stored in
\texttt{\textless{}p\textgreater{}}. \texttt{\textless{}p\textgreater{}}
itself is an identifier with four attributes: \texttt{\^{}rot},
\texttt{\^{}x}, \texttt{\^{}y}, and \texttt{\^{}z}, which have as their
values the rotation of the cube on the z-axis (in rads) and the distance
(in mm) from the origin along the x-, y-, and z- axes respectively. This
pattern will be see very often when working with Cozmo, so it's worth
exploring a bit more. Anything which Cozmo can estimate the location of
(which primarily means objects, faces, and Cozmo itself) has pose
information which is included by the Soar-Cozmo interface on the input
link. The pose information is based on an internal grid Cozmo maintains,
which has as its origin an apparently arbitrary location chosen on
start-up. Pose information is always presented in a \texttt{\^{}pose}
attribute on the thing in question, which connects to an identifier WME.
This identifier then has the four pieces of information outlined above.
Later on, we will create elaborations which add the angle from Cozmo's
heading to the object's location and the distance from Cozmo to the
object, but this information is not provided by the interface. In the
above Soar code, we use \texttt{\textless{}r-val\textgreater{}} and the
rest to capture this information, and use these names, rather than the
names \texttt{\textless{}rot\textgreater{}},
\texttt{\textless{}x\textgreater{}}, and so on to avoid confusion.

The last condition checks that there isn't already a \texttt{\^{}cube}
attribute on the top state with the cube id of the cube we've matched on
the input link. Now that we have this information, particularly
\texttt{\textless{}cid\textgreater{}}, we need check the top state to
make sure we don't already remember a block with the same cube id as the
one we have found. If we do, we shouldn't be remembering it for the
first time (since that would just add a new WME), but updating what we
have. Supposing that we find a match, we now need to create an operator
and propose it. The operator should include all the information we
pulled from the observed cube: the cube id, the object id, and the pose
id. As such, the RHS should look like:

\begin{verbatim}
  (<s> ^operator <op> + =)
  (<op> ^name remember-new-cube
        ^cube-id <cid>
        ^object-id <oid>
        ^pose <pose>)
  (<pose> ^rot <r-val>
      ^x <x-val>
      ^y <y-val>
      ^z <z-val>)
\end{verbatim}

As can be seen, this just creates an operator which has the attributes,
including \texttt{\^{}pose}, which we extracted from the perceived cube.
Once this rule fires, we need to apply the operator, which will store
the cube's information in working memory. Unsurprisingly, the
application rule simply looks for the operator and collects the
information it carries then creates a \texttt{\^{}cube} attribute on the
top state which holds an identifier carrying all of this information.
The entire application rule is

\begin{verbatim}
sp {apply*remember-new-cube
   "If a cube with this id not seen yet, add to wm"
   (state <s> ^operator <op>)
   (<op> ^name remember-new-cube
         ^cube-id <cid>
         ^object-id <oid>
         ^pose <p>)
   (<p> ^rot <r-val>
        ^x <x-val>
        ^y <y-val>
        ^z <z-val>)
-->
   (<s> ^cube <c>)
   (<b> ^cube-id <cid>
        ^object-id <oid>
        ^pose <pose>)
   (<pose> ^rot <r-val>
        ^x <x-val>
        ^y <y-val>
        ^z <z-val>)
}
\end{verbatim}

\hypertarget{updating-known-cubes}{%
\subsubsection{Updating Known Cubes}\label{updating-known-cubes}}

Just memorizing all the information about a cube the first time we see
it isn't enough, since cubes may move around. Cozmo also needs to be
checking whether it sees a cube it already memorized in a different
place than expected, and merely update the existing \texttt{\^{}cube}
attribute if it does. Since we still need all the information about the
cube, the LHS will look very similar to the LHS of the initial
remembering rule, but instead of looking for the \emph{absence} of a
remembered cube with the same cube id, we want to look for its
\emph{presence}. Thus, we want to copy and then slightly change
\texttt{cozmo*propose*remember-new-cube} into a new rule
\texttt{cozmo*propose*update-cube-knowledge}. Just like before, we want
to search the input link for an object with the relevant attributes.
However, we also want to match a \texttt{\^{}cube} attribute on the top
state which has a cube id equal to the cube id of the object on the
input link to ensure we actually know about this cube. Thus, the new
rule looks like

\begin{verbatim}
sp {cozmo*propose*update-cube-knowledge
   "Propose an operator to update cube information"
   (state <s> ^name cozmo
              ^io.input-link.object <obj>
              ^cube <c>)
   (<obj> ^type cube
          ^cube-id <cid>
          ^object-id <oid>
          ^pose <p>)
   (<p> ^rot <r-val>
        ^x <x-val>
        ^y <y-val>
        ^z <z-val>)
   (<c> ^cube-id <cid>)
-->
   (<s> ^operator <op> + =)
   (<op> ^name update-cube-knowledge
         ^cube-id <cid>
         ^object-id <oid>
         ^pose <pose>)
   (<pose> ^rot <r-val>
        ^x <x-val>
        ^y <y-val>
        ^z <z-val>)
}
\end{verbatim}

The application rule for this operator has an similar LHS to the
application rule for \texttt{remember-new-cube}, since the
\texttt{update-cube-knowledge} operator has the same information as the
\texttt{remember-new-cube} operator. However, now we also need to find
and capture in a variable (\texttt{\textless{}c\textgreater{}}) the
\texttt{\^{}cube} WME on the top state which matches the cube's cube id,
so that we can alter it. This means making two changes. First, add a
search for a \texttt{\^{}cube} augmentation to the top state:

\begin{verbatim}
(state <s> ^operator <op>
           ^cube <c>)
\end{verbatim}

Note that the variable \texttt{\textless{}c\textgreater{}} captures the
relevant identifier on the top state. This allows us to remove it
correctly later on, so we can replace it with more up-to-date
information. We also need to check to make sure that the cube
\texttt{\textless{}c\textgreater{}} has the proper cube id:

\begin{verbatim}
(<c> ^cube-id <cid>)
\end{verbatim}

Since this condition needs the variable
\texttt{\textless{}cid\textgreater{}} to exist, it must come after the
condition which captures the cube id stored in the operator.

The RHS is also quite similar to the RHS of the remembering production,
because we are essentially doing the same thing, but just removing the
old augmentation first. We need to delete and replace the WME because
Soar does not allow direct manipulation of WMEs. Thus, we can
essentially copy the RHS of the \texttt{apply*remember-new-cube}
production and add an additional effect before the other effects:

\begin{verbatim}
-(<s> ^cube <c>)
\end{verbatim}

\hypertarget{remembering-and-updating-faces}{%
\subsubsection{Remembering and Updating
Faces}\label{remembering-and-updating-faces}}

The productions to remember and update faces are very similar to those
for remembering and updating cubes. The difference is purely in what
augmentations we're capturing from faces on the input link. Faces, like
objects, have pose information which we want to capture, so this much of
the Soar code is unchanged. However, where cubes have cube-id and
object-id information, faces only have face-ids. Additionlly, faces have
a name (potentially ``unknown'') and an expression (also possibly
``unknown'') associated with them. Given the overall similarity to the
\texttt{remember-new-cube} and \texttt{update-cube-knowledge}
operations, we can just copy the cube productions and make small
alterations.

First, faces are represented as \texttt{\^{}face} augmentations on the
input link rather than \texttt{\^{}object} augmentations, so we need to
change the relevant conditions appropriately. These conditions occur in
the proposal productions, and in the cube rules they look like

\begin{verbatim}
(state <s> ^name cozmo
           ^io.input-link.object <obj>)
\end{verbatim}

We need to change these to match with \texttt{\^{}face} augmentations,
which we can do simply by changing
\texttt{.object\ \textless{}obj\textgreater{}} to
\texttt{.face\ \textless{}f\textgreater{}}. Then we need to collect the
right data from the face augmentation. Of the four conditions which are
matched against the \texttt{\textless{}obj\textgreater{}} variable in
the cube memory productions, only
\texttt{\^{}pose\ \textless{}p\textgreater{}} is still applicable. We
need to replace \texttt{\^{}type\ cube} with
\texttt{\^{}name\ \textless{}n\textgreater{}}, the
\texttt{\^{}cube-id\ \textless{}cid\textgreater{}} with
\texttt{\^{}face-id\ \textless{}fid\textgreater{}}, and
\texttt{\^{}object-id\ \textless{}oid\textgreater{}} with
\texttt{\^{}expression\ \textless{}exp\textgreater{}}. I also recommend
changing variable names like \texttt{\textless{}c\textgreater{}} to
\texttt{\textless{}f\textgreater{}} to better represent that they are
capturing a \texttt{\^{}face} augmentation. We also need to alter the
effects of the productions. For the most part, we make the same
replacements in the RHS of the four new productions as we did to their
LHS. However, when creating the operators in the proposal productions,
we can't use the \texttt{\^{}name} attribute to keep the face's assigned
name, since the \texttt{\^{}name} attribute is already used for the
operator's name. Instead, use \texttt{\^{}face-name} or something
similar. This also means that the application rule condition checking
for that attribute must match with the \texttt{\^{}face-name} attribute
rather than just \texttt{\^{}name}.

\hypertarget{prioritize-remembering}{%
\subsubsection{Prioritize Remembering}\label{prioritize-remembering}}

As of now, Cozmo can both remember and update its memory of cubes and
faces. However, since these operators are prioritized equally Cozmo will
choose between them at random if more than one of these operators is
proposed. Although this will usually be fine in the long run, we really
want Cozmo to prefer remembering new cubes and faces over updating its
memory of old ones. In fact, there are very few proposals we might want
to prioritize equally or more than remembering a newly-seen cube or
face, since that is both fast and often quite important. To ensure
remembering a new things always has priority, we will introduce a very
simple operator comparison. The comparison will check whether two
operators are both \texttt{remember-new-cube} or
\texttt{remember-new-faces} operators and, if not, prioritize the
remembering operator over the other operator. This means that
\texttt{remember-new-cube} and \texttt{remember-new-face} operators will
\emph{always} be chosen first. The comparison production will look
fairly standard:

\begin{verbatim}
sp {cozmo*compare*remember-new
   "Make sure remembering new cubes and faces has highest priority"
   (state <s> ^name cube-stack
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name << remember-new-cube remember-new-face>>)
   (<op2> ^name {<> << remember-new-cube remember-new-face>> })
-->
   (<s> ^operator <op1> > <op2>)
}
\end{verbatim}

The critical condition is the final one, which only matches if
\texttt{\textless{}op2\textgreater{}} isn't a \texttt{remember-new-cube}
or \texttt{remember-new-face} operator. This ensures that all other
operators happen after a new cube is memorized, if one is present.
